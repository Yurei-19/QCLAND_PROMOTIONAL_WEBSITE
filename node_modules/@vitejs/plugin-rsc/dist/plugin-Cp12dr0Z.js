import { n as __toESM } from "./chunk-Dj_d7TT4.js";
import { t as createDebug } from "./dist-yW9-EeG1.js";
import { t as vitePluginRscCore } from "./plugin-BGmSmdwL.js";
import { t as cjsModuleRunnerPlugin } from "./cjs-D2v1gYgq.js";
import { i as toCssVirtual, n as parseIdQuery, r as parseReferenceValidationVirtual, t as parseCssVirtual } from "./shared-CGK4coF3.js";
import { a as hasDirective, n as transformDirectiveProxyExport, o as transformWrapExport, s as findDirectives, t as transformServerActionServer } from "./transforms-B2EJTNXG.js";
import { o as generateEncryptionKey, s as toBase64 } from "./encryption-utils-DdqSKS_O.js";
import { n as createRpcServer } from "./rpc-EIuXyQpO.js";
import { createRequire } from "node:module";
import assert from "node:assert";
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath, pathToFileURL } from "node:url";
import { exactRegex, prefixRegex } from "@rolldown/pluginutils";
import * as esModuleLexer from "es-module-lexer";
import MagicString from "magic-string";
import { toNodeHandler } from "srvx/node";
import { stripLiteral } from "strip-literal";
import * as vite from "vite";
import { defaultServerConditions, isCSSRequest, isFileLoadingAllowed, normalizePath, parseAstAsync } from "vite";
import { crawlFrameworkPkgs } from "vitefu";
import { walk } from "estree-walker";
import { stripVTControlCharacters } from "node:util";
import { createHash } from "node:crypto";

//#region src/plugins/vite-utils.ts
const VALID_ID_PREFIX = `/@id/`;
const NULL_BYTE_PLACEHOLDER = `__x00__`;
const FS_PREFIX = `/@fs/`;
function wrapId(id) {
	return id.startsWith(VALID_ID_PREFIX) ? id : VALID_ID_PREFIX + id.replace("\0", NULL_BYTE_PLACEHOLDER);
}
function withTrailingSlash(path) {
	if (path[path.length - 1] !== "/") return `${path}/`;
	return path;
}
const postfixRE = /[?#].*$/;
function cleanUrl(url) {
	return url.replace(postfixRE, "");
}
function splitFileAndPostfix(path) {
	const file = cleanUrl(path);
	return {
		file,
		postfix: path.slice(file.length)
	};
}
const windowsSlashRE = /\\/g;
function slash(p) {
	return p.replace(windowsSlashRE, "/");
}
const isWindows = typeof process !== "undefined" && process.platform === "win32";
function injectQuery(url, queryToInject) {
	const { file, postfix } = splitFileAndPostfix(url);
	return `${isWindows ? slash(file) : file}?${queryToInject}${postfix[0] === "?" ? `&${postfix.slice(1)}` : postfix}`;
}
function normalizeResolvedIdToUrl(environment, url, resolved) {
	const root = environment.config.root;
	const depsOptimizer = environment.depsOptimizer;
	if (resolved.id.startsWith(withTrailingSlash(root))) url = resolved.id.slice(root.length);
	else if (depsOptimizer?.isOptimizedDepFile(resolved.id) || resolved.id !== "/@react-refresh" && path.isAbsolute(resolved.id) && fs.existsSync(cleanUrl(resolved.id))) url = path.posix.join(FS_PREFIX, resolved.id);
	else url = resolved.id;
	if (url[0] !== "." && url[0] !== "/") url = wrapId(resolved.id);
	return url;
}
function normalizeViteImportAnalysisUrl(environment, id) {
	let url = normalizeResolvedIdToUrl(environment, id, { id });
	if (environment.config.consumer === "client") {
		const mod = environment.moduleGraph.getModuleById(id);
		if (mod && mod.lastHMRTimestamp > 0) url = injectQuery(url, `t=${mod.lastHMRTimestamp}`);
	}
	return url;
}
function prepareError(err) {
	return {
		message: stripVTControlCharacters(err.message),
		stack: stripVTControlCharacters(cleanStack(err.stack || "")),
		id: err.id,
		frame: stripVTControlCharacters(err.frame || ""),
		plugin: err.plugin,
		pluginCode: err.pluginCode?.toString(),
		loc: err.loc
	};
}
function cleanStack(stack) {
	return stack.split(/\n/).filter((l) => /^\s*at/.test(l)).join("\n");
}
function evalValue(rawValue) {
	return new Function(`
    var console, exports, global, module, process, require
    return (\n${rawValue}\n)
  `)();
}
const directRequestRE = /(\?|&)direct=?(?:&|$)/;

//#endregion
//#region src/plugins/find-source-map-url.ts
function vitePluginFindSourceMapURL() {
	return [{
		name: "rsc:findSourceMapURL",
		apply: "serve",
		configureServer(server) {
			server.middlewares.use(async (req, res, next) => {
				const url = new URL(req.url, `http://localhost`);
				if (url.pathname === "/__vite_rsc_findSourceMapURL") {
					let filename = url.searchParams.get("filename");
					let environmentName = url.searchParams.get("environmentName");
					try {
						const map = await findSourceMapURL(server, filename, environmentName);
						res.setHeader("content-type", "application/json");
						if (!map) res.statusCode = 404;
						res.end(JSON.stringify(map ?? {}));
					} catch (e) {
						next(e);
					}
					return;
				}
				next();
			});
		}
	}];
}
async function findSourceMapURL(server, filename, environmentName) {
	if (filename.startsWith("file://")) {
		filename = slash(fileURLToPath(filename));
		if (isFileLoadingAllowed(server.config, filename) && fs.existsSync(filename)) {
			const content = fs.readFileSync(filename, "utf-8");
			return {
				version: 3,
				sources: [filename],
				sourcesContent: [content],
				mappings: "AAAA" + ";AACA".repeat(content.split("\n").length)
			};
		}
		return;
	}
	let mod;
	let map;
	if (environmentName === "Server") {
		mod = server.environments.rsc.moduleGraph.getModuleById(filename);
		map = mod?.transformResult?.map;
		if (map && map.mappings) map = {
			...map,
			mappings: ";;" + map.mappings
		};
	}
	const base = server.config.base.slice(0, -1);
	if (environmentName === "Client") try {
		const url = new URL(filename).pathname.slice(base.length);
		mod = server.environments.client.moduleGraph.urlToModuleMap.get(url);
		map = mod?.transformResult?.map;
	} catch (e) {}
	if (mod && map) return {
		...map,
		sources: [base + mod.url]
	};
}

//#endregion
//#region src/plugins/utils.ts
function sortObject(o) {
	return Object.fromEntries(Object.entries(o).sort(([a], [b]) => a.localeCompare(b)));
}
function withRollupError(ctx, f) {
	function processError(e) {
		if (e && typeof e === "object" && typeof e.pos === "number") return ctx.error(e, e.pos);
		throw e;
	}
	return function(...args) {
		try {
			const result = f.apply(this, args);
			if (result instanceof Promise) return result.catch((e) => processError(e));
			return result;
		} catch (e) {
			processError(e);
		}
	};
}
function createVirtualPlugin(name, load) {
	const virtualId = "virtual:" + name;
	const resolvedId = "\0" + virtualId;
	return {
		name: `rsc:virtual-${name}`,
		resolveId: {
			filter: { id: exactRegex(virtualId) },
			handler(source) {
				if (source === virtualId) return resolvedId;
			}
		},
		load: {
			filter: { id: exactRegex(resolvedId) },
			handler(id, options) {
				if (id === resolvedId) return load.apply(this, [id, options]);
			}
		}
	};
}
function normalizeRelativePath(s) {
	s = normalizePath(s);
	return s[0] === "." ? s : "./" + s;
}
function getEntrySource(config, name) {
	const input = config.build.rollupOptions.input;
	if (!name) return getFallbackRollupEntry(input).source;
	if (typeof input === "object" && !Array.isArray(input) && name in input && typeof input[name] === "string") return input[name];
	throw new Error(`[vite-rsc:getEntrySource] expected 'build.rollupOptions.input' to be an object with a '${name}' property that is a string, but got ${JSON.stringify(input)}`);
}
function getFallbackRollupEntry(input = {}) {
	const inputEntries = Object.entries(normalizeRollupOpitonsInput(input));
	if (inputEntries.length === 1) {
		const [name, source] = inputEntries[0];
		return {
			name,
			source
		};
	}
	throw new Error(`[vite-rsc] cannot determine fallback entry name from multiple entries, please specify the entry name explicitly`);
}
function normalizeRollupOpitonsInput(input = {}) {
	if (typeof input === "string") input = [input];
	if (Array.isArray(input)) return Object.fromEntries(input.map((file) => [path.basename(file).slice(0, -path.extname(file).length), file]));
	return input;
}
function hashString(v) {
	return createHash("sha256").update(v).digest().toString("hex").slice(0, 12);
}
function getFetchHandlerExport(exports) {
	if ("default" in exports) {
		const default_ = exports.default;
		if (default_ && typeof default_ === "object" && "fetch" in default_ && typeof default_.fetch === "function") return default_.fetch;
		if (typeof default_ === "function") return default_;
	}
	throw new Error("Invalid server handler entry");
}

//#endregion
//#region src/plugins/import-environment.ts
const ENV_IMPORTS_MANIFEST_NAME = "__vite_rsc_env_imports_manifest.js";
const ENV_IMPORTS_MANIFEST_PLACEHOLDER = "virtual:vite-rsc/env-imports-manifest";
const ENV_IMPORTS_ENTRY_FALLBACK = "virtual:vite-rsc/env-imports-entry-fallback";
function ensureEnvironmentImportsEntryFallback({ environments }) {
	for (const [name, config] of Object.entries(environments)) {
		if (name === "client") continue;
		const input = normalizeRollupOpitonsInput(config.build?.rollupOptions?.input);
		if (Object.keys(input).length === 0) {
			config.build = config.build || {};
			config.build.rollupOptions = config.build.rollupOptions || {};
			config.build.rollupOptions.input = { __vite_rsc_env_imports_entry_fallback: ENV_IMPORTS_ENTRY_FALLBACK };
		}
	}
}
function vitePluginImportEnvironment(manager) {
	return [{
		name: "rsc:import-environment",
		resolveId: {
			filter: { id: exactRegex(ENV_IMPORTS_MANIFEST_PLACEHOLDER) },
			handler(source) {
				if (source === ENV_IMPORTS_MANIFEST_PLACEHOLDER) return {
					id: ENV_IMPORTS_MANIFEST_PLACEHOLDER,
					external: true
				};
			}
		},
		buildStart() {
			if (this.environment.mode !== "build") return;
			const emitted = /* @__PURE__ */ new Set();
			for (const byTargetEnv of Object.values(manager.environmentImportMetaMap)) {
				const imports = byTargetEnv[this.environment.name];
				if (!imports) continue;
				for (const meta of Object.values(imports)) if (!emitted.has(meta.resolvedId)) {
					emitted.add(meta.resolvedId);
					this.emitFile({
						type: "chunk",
						id: meta.resolvedId
					});
				}
			}
		},
		transform: {
			filter: { code: "import.meta.viteRsc.import" },
			async handler(code, id) {
				if (!code.includes("import.meta.viteRsc.import")) return;
				const { server } = manager;
				const s = new MagicString(code);
				for (const match of stripLiteral(code).matchAll(/import\.meta\.viteRsc\.import\s*(<[\s\S]*?>)?\s*\(([\s\S]*?)\)/dg)) {
					const [argStart, argEnd] = match.indices[2];
					const [specifier, options] = evalValue(`[${code.slice(argStart, argEnd).trim()}]`);
					const environmentName = options.environment;
					let resolvedId;
					if (this.environment.mode === "dev") {
						const targetEnv = server.environments[environmentName];
						assert(targetEnv, `[vite-rsc] unknown environment '${environmentName}'`);
						const resolved = await targetEnv.pluginContainer.resolveId(specifier, id);
						assert(resolved, `[vite-rsc] failed to resolve '${specifier}' in environment '${environmentName}'`);
						resolvedId = resolved.id;
					} else {
						const targetEnvConfig = manager.config.environments[environmentName];
						assert(targetEnvConfig, `[vite-rsc] unknown environment '${environmentName}'`);
						const resolved = await this.resolve(specifier, id);
						assert(resolved, `[vite-rsc] failed to resolve '${specifier}' in environment '${environmentName}'`);
						resolvedId = resolved.id;
					}
					const sourceEnv = this.environment.name;
					const targetEnv = environmentName;
					manager.environmentImportMetaMap[sourceEnv] ??= {};
					manager.environmentImportMetaMap[sourceEnv][targetEnv] ??= {};
					manager.environmentImportMetaMap[sourceEnv][targetEnv][resolvedId] = {
						resolvedId,
						targetEnv,
						sourceEnv,
						specifier
					};
					let replacement;
					if (this.environment.mode === "dev") replacement = `globalThis.__VITE_ENVIRONMENT_RUNNER_IMPORT__(${JSON.stringify(environmentName)}, ${JSON.stringify(resolvedId)})`;
					else {
						const relativeId = manager.toRelativeId(resolvedId);
						replacement = `(await import(${JSON.stringify(ENV_IMPORTS_MANIFEST_PLACEHOLDER)})).default[${JSON.stringify(relativeId)}]()`;
					}
					const [start, end] = match.indices[0];
					s.overwrite(start, end, replacement);
				}
				if (s.hasChanged()) return {
					code: s.toString(),
					map: s.generateMap({ hires: "boundary" })
				};
			}
		},
		renderChunk(code, chunk) {
			if (code.includes(ENV_IMPORTS_MANIFEST_PLACEHOLDER)) {
				const replacement = normalizeRelativePath(path.relative(path.join(chunk.fileName, ".."), ENV_IMPORTS_MANIFEST_NAME));
				code = code.replaceAll(ENV_IMPORTS_MANIFEST_PLACEHOLDER, () => replacement);
				return { code };
			}
		}
	}, createVirtualPlugin(ENV_IMPORTS_ENTRY_FALLBACK.slice(8), () => {
		return `export default "__vite_rsc_env_imports_entry_fallback";`;
	})];
}
function writeEnvironmentImportsManifest(manager) {
	if (Object.keys(manager.environmentImportMetaMap).length === 0) return;
	for (const [sourceEnv, byTargetEnv] of Object.entries(manager.environmentImportMetaMap)) {
		const sourceOutDir = manager.config.environments[sourceEnv].build.outDir;
		const manifestPath = path.join(sourceOutDir, ENV_IMPORTS_MANIFEST_NAME);
		let code = "export default {\n";
		for (const [_targetEnv, imports] of Object.entries(byTargetEnv)) for (const [resolvedId, meta] of Object.entries(imports)) {
			const bundle = manager.bundles[meta.targetEnv];
			if (!bundle) throw new Error(`[vite-rsc] missing bundle for environment import: ${meta.targetEnv}`);
			const chunk = Object.values(bundle).find((c) => c.type === "chunk" && c.facadeModuleId === resolvedId);
			if (!chunk) throw new Error(`[vite-rsc] missing output for environment import: ${resolvedId}`);
			const targetOutDir = manager.config.environments[meta.targetEnv].build.outDir;
			const relativePath = normalizeRelativePath(path.relative(sourceOutDir, path.join(targetOutDir, chunk.fileName)));
			const relativeId = manager.toRelativeId(resolvedId);
			code += `  ${JSON.stringify(relativeId)}: () => import(${JSON.stringify(relativePath)}),\n`;
		}
		code += "}\n";
		fs.writeFileSync(manifestPath, code);
	}
}

//#endregion
//#region src/plugins/resolved-id-proxy.ts
const RESOLVED_ID_PROXY_PREFIX = "virtual:vite-rsc/resolved-id/";
function toResolvedIdProxy(resolvedId) {
	return RESOLVED_ID_PROXY_PREFIX + encodeURIComponent(resolvedId);
}
function withResolvedIdProxy(resolvedId) {
	return resolvedId.startsWith("\0") ? toResolvedIdProxy(resolvedId) : resolvedId;
}
function fromResolvedIdProxy(source) {
	if (!source.startsWith(RESOLVED_ID_PROXY_PREFIX)) return;
	const clean = source.split("?")[0];
	return decodeURIComponent(clean.slice(29));
}
/**
* Vite plugin that resolves proxy import specifiers to the original resolved IDs.
*/
function vitePluginResolvedIdProxy() {
	return {
		name: "rsc:resolved-id-proxy",
		resolveId: {
			filter: { id: prefixRegex(RESOLVED_ID_PROXY_PREFIX) },
			handler(source) {
				const originalId = fromResolvedIdProxy(source);
				if (originalId !== void 0) return originalId;
			}
		}
	};
}

//#endregion
//#region src/plugins/scan.ts
function scanBuildStripPlugin({ manager }) {
	return {
		name: "rsc:scan-strip",
		apply: "build",
		enforce: "post",
		transform: { async handler(code, _id, _options) {
			if (!manager.isScanBuild) return;
			return {
				code: await transformScanBuildStrip(code),
				map: { mappings: "" }
			};
		} }
	};
}
const importGlobRE = /\bimport\.meta\.glob(?:<\w+>)?\s*\(/g;
async function transformScanBuildStrip(code) {
	const [imports] = esModuleLexer.parse(code);
	let output = imports.map((e) => e.n && `import ${JSON.stringify(e.n)};\n`).filter(Boolean).join("");
	if (importGlobRE.test(code)) {
		walk(await parseAstAsync(code), { enter(node) {
			if (node.type === "CallExpression" && node.callee.type === "MemberExpression" && node.callee.object.type === "MetaProperty" && node.callee.object.meta.type === "Identifier" && node.callee.object.meta.name === "import" && node.callee.object.property.type === "Identifier" && node.callee.object.property.name === "meta" && node.callee.property.type === "Identifier" && node.callee.property.name === "glob") {
				const importMetaGlob = code.slice(node.start, node.end);
				output += `console.log(${importMetaGlob});\n`;
			}
		} });
		output += "";
	}
	return output;
}

//#endregion
//#region src/plugins/validate-import.ts
function validateImportPlugin() {
	return {
		name: "rsc:validate-imports",
		resolveId: {
			order: "pre",
			filter: { id: /^(client-only|server-only)$/ },
			async handler(source, _importer, options) {
				if ("scan" in options && options.scan) return;
				if (source === "client-only" || source === "server-only") {
					if (source === "client-only" && this.environment.name === "rsc" || source === "server-only" && this.environment.name !== "rsc") return {
						id: `\0virtual:vite-rsc/validate-imports/invalid/${source}`,
						moduleSideEffects: true
					};
					return {
						id: `\0virtual:vite-rsc/validate-imports/valid/${source}`,
						moduleSideEffects: false
					};
				}
			}
		},
		load: {
			filter: { id: prefixRegex("\0virtual:vite-rsc/validate-imports/") },
			handler(id) {
				if (id.startsWith("\0virtual:vite-rsc/validate-imports/invalid/")) return `throw new Error("invalid import of '${id.slice(id.lastIndexOf("/") + 1)}'")`;
				if (id.startsWith("\0virtual:vite-rsc/validate-imports/")) return `export {}`;
			}
		},
		transform: {
			order: "post",
			filter: { id: prefixRegex("\0virtual:vite-rsc/validate-imports/invalid/") },
			async handler(_code, id) {
				if (this.environment.mode === "dev") {
					if (id.startsWith(`\0virtual:vite-rsc/validate-imports/invalid/`)) validateImportChain(getImportChainDev(this.environment, id), this.environment.name, this.environment.config.root);
				}
			}
		},
		buildEnd() {
			if (this.environment.mode === "build") {
				validateImportChain(getImportChainBuild(this, "\0virtual:vite-rsc/validate-imports/invalid/server-only"), this.environment.name, this.environment.config.root);
				validateImportChain(getImportChainBuild(this, "\0virtual:vite-rsc/validate-imports/invalid/client-only"), this.environment.name, this.environment.config.root);
			}
		}
	};
}
function getImportChainDev(environment, id) {
	const chain = [];
	const recurse = (id) => {
		if (chain.includes(id)) return;
		const info = environment.moduleGraph.getModuleById(id);
		if (!info) return;
		chain.push(id);
		const next = [...info.importers][0];
		if (next && next.id) recurse(next.id);
	};
	recurse(id);
	return chain;
}
function getImportChainBuild(ctx, id) {
	const chain = [];
	const recurse = (id) => {
		if (chain.includes(id)) return;
		const info = ctx.getModuleInfo(id);
		if (!info) return;
		chain.push(id);
		const next = info.importers[0];
		if (next) recurse(next);
	};
	recurse(id);
	return chain;
}
function validateImportChain(chain, environmentName, root) {
	if (chain.length === 0) return;
	const id = chain[0];
	const source = id.slice(id.lastIndexOf("/") + 1);
	let result = `'${source}' cannot be imported in ${source === "server-only" ? "client" : "server"} build ('${environmentName}' environment):\n`;
	result += chain.slice(1, 6).map((id, i) => " ".repeat(i + 1) + `imported by ${path.relative(root, id).replaceAll("\0", "")}\n`).join("");
	if (chain.length > 6) result += " ".repeat(7) + "...\n";
	const error = new Error(result);
	if (chain[1]) Object.assign(error, { id: chain[1] });
	throw error;
}

//#endregion
//#region src/plugin.ts
const isRolldownVite = "rolldownVersion" in vite;
const BUILD_ASSETS_MANIFEST_NAME = "__vite_rsc_assets_manifest.js";
const PKG_NAME = "@vitejs/plugin-rsc";
const REACT_SERVER_DOM_NAME = `${PKG_NAME}/vendor/react-server-dom`;
const VIRTUAL_ENTRIES = { browser: "virtual:vite-rsc/entry-browser" };
const require = createRequire(import.meta.url);
function resolvePackage(name) {
	return pathToFileURL(require.resolve(name)).href;
}
/**
* @experimental
*/
var RscPluginManager = class {
	server;
	config;
	bundles = {};
	buildAssetsManifest;
	isScanBuild = false;
	clientReferenceMetaMap = {};
	clientReferenceGroups = {};
	serverReferenceMetaMap = {};
	serverResourcesMetaMap = {};
	environmentImportMetaMap = {};
	stabilize() {
		this.clientReferenceMetaMap = sortObject(this.clientReferenceMetaMap);
		this.serverResourcesMetaMap = sortObject(this.serverResourcesMetaMap);
	}
	toRelativeId(id) {
		return normalizePath(path.relative(this.config.root, id));
	}
	writeAssetsManifest(environmentNames) {
		const assetsManifestCode = `export default ${serializeValueWithRuntime(this.buildAssetsManifest)}`;
		for (const name of environmentNames) {
			const manifestPath = path.join(this.config.environments[name].build.outDir, BUILD_ASSETS_MANIFEST_NAME);
			fs.writeFileSync(manifestPath, assetsManifestCode);
		}
	}
	writeEnvironmentImportsManifest() {
		writeEnvironmentImportsManifest(this);
	}
};
/** @experimental */
function getPluginApi(config) {
	return config.plugins.find((p) => p.name === "rsc:minimal")?.api;
}
/** @experimental */
function vitePluginRscMinimal(rscPluginOptions = {}, manager = new RscPluginManager()) {
	return [
		{
			name: "rsc:minimal",
			enforce: "pre",
			api: { manager },
			async config() {
				await esModuleLexer.init;
			},
			configResolved(config) {
				manager.config = config;
				for (const e of Object.values(config.environments)) e.build.outDir = path.resolve(config.root, e.build.outDir);
			},
			configureServer(server_) {
				manager.server = server_;
			}
		},
		{
			name: "rsc:vite-client-raw-import",
			transform: {
				order: "post",
				filter: { code: "__vite_rsc_raw_import__" },
				handler(code) {
					if (code.includes("__vite_rsc_raw_import__")) return code.replace("__vite_rsc_raw_import__", "import");
				}
			}
		},
		...vitePluginRscCore(),
		...vitePluginUseClient(rscPluginOptions, manager),
		...vitePluginUseServer(rscPluginOptions, manager),
		...vitePluginDefineEncryptionKey(rscPluginOptions),
		{
			name: "rsc:reference-validation",
			apply: "serve",
			load: {
				filter: { id: prefixRegex("\0virtual:vite-rsc/reference-validation?") },
				handler(id, _options) {
					if (id.startsWith("\0virtual:vite-rsc/reference-validation?")) {
						const parsed = parseReferenceValidationVirtual(id);
						assert(parsed);
						if (parsed.type === "client") {
							if (Object.values(manager.clientReferenceMetaMap).find((meta) => meta.referenceKey === parsed.id)) return `export {}`;
						}
						if (parsed.type === "server") {
							if (Object.values(manager.serverReferenceMetaMap).find((meta) => meta.referenceKey === parsed.id)) return `export {}`;
						}
						this.error(`[vite-rsc] invalid ${parsed.type} reference '${parsed.id}'`);
					}
				}
			}
		},
		scanBuildStripPlugin({ manager }),
		vitePluginResolvedIdProxy()
	];
}
function vitePluginRsc(rscPluginOptions = {}) {
	const manager = new RscPluginManager();
	const buildApp = async (builder) => {
		const colors = await import("./picocolors-BRyoHAlU.js").then((m) => /* @__PURE__ */ __toESM(m.default, 1));
		const logStep = (msg) => {
			builder.config.logger.info(colors.blue(msg));
		};
		const rscOutDir = builder.environments.rsc.config.build.outDir;
		const ssrOutDir = builder.environments.ssr.config.build.outDir;
		const rscInsideSsr = path.normalize(rscOutDir).startsWith(path.normalize(ssrOutDir) + path.sep);
		const tempRscOutDir = path.join(builder.config.root, "node_modules", ".vite-rsc-temp", "rsc");
		ensureEnvironmentImportsEntryFallback(builder.config);
		manager.isScanBuild = true;
		builder.environments.rsc.config.build.write = false;
		builder.environments.ssr.config.build.write = false;
		logStep("[1/5] analyze client references...");
		await builder.build(builder.environments.rsc);
		logStep("[2/5] analyze server references...");
		await builder.build(builder.environments.ssr);
		manager.isScanBuild = false;
		builder.environments.rsc.config.build.write = true;
		builder.environments.ssr.config.build.write = true;
		logStep("[3/5] build rsc environment...");
		await builder.build(builder.environments.rsc);
		if (rscInsideSsr) {
			if (fs.existsSync(tempRscOutDir)) fs.rmSync(tempRscOutDir, { recursive: true });
			fs.mkdirSync(path.dirname(tempRscOutDir), { recursive: true });
			fs.renameSync(rscOutDir, tempRscOutDir);
		}
		manager.stabilize();
		logStep("[4/5] build client environment...");
		await builder.build(builder.environments.client);
		logStep("[5/5] build ssr environment...");
		await builder.build(builder.environments.ssr);
		if (rscInsideSsr) {
			if (fs.existsSync(rscOutDir)) fs.rmSync(rscOutDir, { recursive: true });
			fs.mkdirSync(path.dirname(rscOutDir), { recursive: true });
			fs.renameSync(tempRscOutDir, rscOutDir);
		}
		manager.writeAssetsManifest(["ssr", "rsc"]);
		manager.writeEnvironmentImportsManifest();
	};
	let hasReactServerDomWebpack = false;
	return [
		{
			name: "rsc",
			async config(config, env) {
				if (config.rsc) Object.assign(rscPluginOptions, vite.mergeConfig(config.rsc, rscPluginOptions));
				const result = await crawlFrameworkPkgs({
					root: process.cwd(),
					isBuild: env.command === "build",
					isFrameworkPkgByJson(pkgJson) {
						if ([PKG_NAME, "react-dom"].includes(pkgJson.name)) return;
						const deps = pkgJson["peerDependencies"];
						return deps && "react" in deps;
					}
				});
				const noExternal = [
					"react",
					"react-dom",
					"server-only",
					"client-only",
					PKG_NAME,
					...result.ssr.noExternal.sort()
				];
				hasReactServerDomWebpack = result.ssr.noExternal.includes("react-server-dom-webpack");
				const reactServerDomPackageName = hasReactServerDomWebpack ? "react-server-dom-webpack" : REACT_SERVER_DOM_NAME;
				return {
					appType: config.appType ?? "custom",
					define: { "import.meta.env.__vite_rsc_build__": JSON.stringify(env.command === "build") },
					environments: {
						client: {
							build: {
								outDir: config.environments?.client?.build?.outDir ?? "dist/client",
								rollupOptions: { input: rscPluginOptions.entries?.client && { index: rscPluginOptions.entries.client } }
							},
							optimizeDeps: {
								include: ["react-dom/client", `${reactServerDomPackageName}/client.browser`],
								exclude: [PKG_NAME]
							}
						},
						ssr: {
							build: {
								outDir: config.environments?.ssr?.build?.outDir ?? "dist/ssr",
								copyPublicDir: false,
								rollupOptions: { input: rscPluginOptions.entries?.ssr && { index: rscPluginOptions.entries.ssr } }
							},
							resolve: { noExternal },
							optimizeDeps: {
								include: [
									"react",
									"react-dom",
									"react/jsx-runtime",
									"react/jsx-dev-runtime",
									"react-dom/server.edge",
									"react-dom/static.edge",
									`${reactServerDomPackageName}/client.edge`
								],
								exclude: [PKG_NAME]
							}
						},
						rsc: {
							build: {
								outDir: config.environments?.rsc?.build?.outDir ?? "dist/rsc",
								copyPublicDir: false,
								emitAssets: true,
								rollupOptions: { input: rscPluginOptions.entries?.rsc && { index: rscPluginOptions.entries.rsc } }
							},
							resolve: {
								conditions: ["react-server", ...defaultServerConditions],
								noExternal
							},
							optimizeDeps: {
								include: [
									"react",
									"react-dom",
									"react/jsx-runtime",
									"react/jsx-dev-runtime",
									`${reactServerDomPackageName}/server.edge`,
									`${reactServerDomPackageName}/client.edge`
								],
								exclude: [PKG_NAME]
							}
						}
					},
					builder: rscPluginOptions.customBuildApp ? void 0 : {
						sharedPlugins: true,
						sharedConfigBuild: true,
						async buildApp(builder) {
							if (!rscPluginOptions.useBuildAppHook) await buildApp(builder);
						}
					}
				};
			},
			configResolved() {
				if (Number(vite.version.split(".")[0]) >= 7) rscPluginOptions.useBuildAppHook ??= true;
			},
			buildApp: { async handler(builder) {
				if (rscPluginOptions.customBuildApp) return;
				if (rscPluginOptions.useBuildAppHook) await buildApp(builder);
			} },
			configureServer(server) {
				globalThis.__VITE_ENVIRONMENT_RUNNER_IMPORT__ = async function(environmentName, id) {
					const environment = server.environments[environmentName];
					if (!environment) throw new Error(`[vite-rsc] unknown environment '${environmentName}'`);
					if (!vite.isRunnableDevEnvironment(environment)) throw new Error(`[vite-rsc] environment '${environmentName}' is not runnable`);
					return environment.runner.import(id);
				};
				const oldSend = server.environments.client.hot.send;
				server.environments.client.hot.send = async function(...args) {
					const e = args[0];
					if (e && typeof e === "object" && e.type === "update") {
						for (const update of e.updates) if (update.type === "js-update") {
							const mod = server.environments.client.moduleGraph.urlToModuleMap.get(update.path);
							if (mod && mod.id && manager.clientReferenceMetaMap[mod.id]) {
								const serverMod = server.environments.rsc.moduleGraph.getModuleById(mod.id);
								if (serverMod) server.environments.rsc.moduleGraph.invalidateModule(serverMod);
							}
						}
					}
					return oldSend.apply(this, args);
				};
				if (rscPluginOptions.serverHandler === false) return;
				const options = rscPluginOptions.serverHandler ?? {
					environmentName: "rsc",
					entryName: "index"
				};
				const environment = server.environments[options.environmentName];
				const source = getEntrySource(environment.config, options.entryName);
				return () => {
					server.middlewares.use(async (req, res, next) => {
						try {
							const resolved = await environment.pluginContainer.resolveId(source);
							assert(resolved, `[vite-rsc] failed to resolve server handler '${source}'`);
							const fetchHandler = getFetchHandlerExport(await environment.runner.import(resolved.id));
							req.url = req.originalUrl ?? req.url;
							await toNodeHandler(fetchHandler)(req, res);
						} catch (e) {
							next(e);
						}
					});
				};
			},
			async configurePreviewServer(server) {
				if (rscPluginOptions.serverHandler === false) return;
				const options = rscPluginOptions.serverHandler ?? {
					environmentName: "rsc",
					entryName: "index"
				};
				const handler = toNodeHandler(getFetchHandlerExport(await import(pathToFileURL(path.join(manager.config.environments[options.environmentName].build.outDir, `${options.entryName}.js`)).href)));
				server.middlewares.use((req, _res, next) => {
					delete req.headers["accept-encoding"];
					next();
				});
				return () => {
					server.middlewares.use(async (req, res, next) => {
						try {
							req.url = req.originalUrl ?? req.url;
							await handler(req, res);
						} catch (e) {
							next(e);
						}
					});
				};
			},
			async hotUpdate(ctx) {
				if (isCSSRequest(ctx.file)) {
					if (this.environment.name === "client") return;
				}
				if (ctx.modules.map((mod) => mod.id).filter((v) => v !== null).length === 0) return;
				if (this.environment.name === "rsc") {
					for (const mod of ctx.modules) if (mod.type === "js" && mod.id && mod.id in manager.clientReferenceMetaMap) try {
						await this.environment.transformRequest(mod.url);
					} catch {}
				}
				function isInsideClientBoundary(mods) {
					const visited = /* @__PURE__ */ new Set();
					function recurse(mod) {
						if (!mod.id) return false;
						if (manager.clientReferenceMetaMap[mod.id]) return true;
						if (visited.has(mod.id)) return false;
						visited.add(mod.id);
						for (const importer of mod.importers) if (recurse(importer)) return true;
						return false;
					}
					return mods.some((mod) => recurse(mod));
				}
				if (!isInsideClientBoundary(ctx.modules)) {
					if (this.environment.name === "rsc") {
						if (ctx.modules.length === 1) {
							const importers = [...ctx.modules[0].importers];
							if (importers.length > 0 && importers.every((m) => m.id && isCSSRequest(m.id))) return [];
						}
						for (const mod of ctx.modules) if (mod.type === "js") try {
							await this.environment.transformRequest(mod.url);
						} catch (e) {
							manager.server.environments.client.hot.send({
								type: "error",
								err: prepareError(e)
							});
							throw e;
						}
						ctx.server.environments.client.hot.send({
							type: "custom",
							event: "rsc:update",
							data: { file: ctx.file }
						});
					}
					if (this.environment.name === "client") {
						if (ctx.server.environments.rsc.moduleGraph.getModuleById(ctx.file)) {
							for (const clientMod of ctx.modules) for (const importer of clientMod.importers) if (importer.id && isCSSRequest(importer.id)) await this.environment.reloadModule(importer);
							return [];
						}
					}
				}
			}
		},
		{
			name: "rsc:react-server-dom-webpack-alias",
			resolveId: {
				order: "pre",
				filter: { id: prefixRegex(`${PKG_NAME}/vendor/react-server-dom/`) },
				async handler(source, importer, options) {
					if (hasReactServerDomWebpack && source.startsWith(`${PKG_NAME}/vendor/react-server-dom/`)) {
						const newSource = source.replace(`${PKG_NAME}/vendor/react-server-dom`, "react-server-dom-webpack");
						return await this.resolve(newSource, importer, {
							...options,
							skipSelf: true
						});
					}
				}
			}
		},
		{
			name: "rsc:load-environment-module",
			transform: {
				filter: { code: "import.meta.viteRsc.loadModule" },
				async handler(code) {
					if (!code.includes("import.meta.viteRsc.loadModule")) return;
					const { server } = manager;
					const s = new MagicString(code);
					for (const match of stripLiteral(code).matchAll(/import\.meta\.viteRsc\.loadModule\(([\s\S]*?)\)/dg)) {
						const [argStart, argEnd] = match.indices[1];
						const [environmentName, entryName] = evalValue(`[${code.slice(argStart, argEnd).trim()}]`);
						let replacement;
						if (this.environment.mode === "dev" && rscPluginOptions.loadModuleDevProxy) replacement = `import("virtual:vite-rsc/rpc-client").then((module) => module.createRpcClient(${JSON.stringify({
							environmentName,
							entryName
						})}))`;
						else if (this.environment.mode === "dev") {
							const environment = server.environments[environmentName];
							const source = getEntrySource(environment.config, entryName);
							const resolved = await environment.pluginContainer.resolveId(source);
							assert(resolved, `[vite-rsc] failed to resolve entry '${source}'`);
							replacement = `globalThis.__VITE_ENVIRONMENT_RUNNER_IMPORT__(${JSON.stringify(environmentName)}, ${JSON.stringify(resolved.id)})`;
						} else {
							const environment = manager.config.environments[environmentName];
							const targetName = entryName || getFallbackRollupEntry(environment.build.rollupOptions.input).name;
							replacement = JSON.stringify(`__vite_rsc_load_module_start__:` + JSON.stringify({
								fromEnv: this.environment.name,
								toEnv: environmentName,
								targetFileName: `${targetName}.js`
							}) + `:__vite_rsc_load_module_end__`);
						}
						const [start, end] = match.indices[0];
						s.overwrite(start, end, replacement);
					}
					if (s.hasChanged()) return {
						code: s.toString(),
						map: s.generateMap({ hires: "boundary" })
					};
				}
			},
			renderChunk(code, chunk) {
				if (!code.includes("__vite_rsc_load_module")) return;
				const { config } = manager;
				const s = new MagicString(code);
				for (const match of code.matchAll(/[`'"]__vite_rsc_load_module_start__:([\s\S]*?):__vite_rsc_load_module_end__[`'"]/dg)) {
					const markerString = evalValue(match[0]);
					const { fromEnv, toEnv, targetFileName } = JSON.parse(markerString.slice(31, -29));
					const importPath = normalizeRelativePath(path.relative(path.join(config.environments[fromEnv].build.outDir, chunk.fileName, ".."), path.join(config.environments[toEnv].build.outDir, targetFileName)));
					const replacement = `(import(${JSON.stringify(importPath)}))`;
					const [start, end] = match.indices[0];
					s.overwrite(start, end, replacement);
				}
				if (s.hasChanged()) return {
					code: s.toString(),
					map: s.generateMap({ hires: "boundary" })
				};
			}
		},
		{
			name: "vite-rsc-load-module-dev-proxy",
			configureServer(server) {
				if (!rscPluginOptions.loadModuleDevProxy) return;
				async function createHandler(url) {
					const { environmentName, entryName } = Object.fromEntries(url.searchParams);
					assert(environmentName);
					const environment = server.environments[environmentName];
					const source = getEntrySource(environment.config, entryName);
					const resolvedEntry = await environment.pluginContainer.resolveId(source);
					assert(resolvedEntry, `[vite-rsc] failed to resolve entry '${source}'`);
					return createRpcServer(new Proxy({}, { get(_target, p, _receiver) {
						if (typeof p !== "string" || p === "then") return;
						return async (...args) => {
							return (await environment.runner.import(resolvedEntry.id))[p](...args);
						};
					} }));
				}
				server.middlewares.use(async (req, res, next) => {
					const url = new URL(req.url ?? "/", `http://localhost`);
					if (url.pathname === "/__vite_rsc_load_module_dev_proxy") {
						try {
							await toNodeHandler(await createHandler(url))(req, res);
						} catch (e) {
							next(e);
						}
						return;
					}
					next();
				});
			}
		},
		{
			name: "rsc:virtual:vite-rsc/rpc-client",
			resolveId: {
				filter: { id: exactRegex("virtual:vite-rsc/rpc-client") },
				handler(source) {
					if (source === "virtual:vite-rsc/rpc-client") return `\0${source}`;
				}
			},
			load: {
				filter: { id: exactRegex("\0virtual:vite-rsc/rpc-client") },
				handler(id) {
					if (id === "\0virtual:vite-rsc/rpc-client") {
						const { server } = manager;
						const origin = server.resolvedUrls?.local[0];
						assert(origin, "[vite-rsc] no server for loadModuleDevProxy");
						return `\
import * as __vite_rsc_rpc from "@vitejs/plugin-rsc/utils/rpc";
export function createRpcClient(params) {
  const endpoint =
    "${origin}" +
    "__vite_rsc_load_module_dev_proxy?" +
    new URLSearchParams(params);
  return __vite_rsc_rpc.createRpcClient({ endpoint });
}
          `;
					}
				}
			}
		},
		{
			name: "rsc:virtual:vite-rsc/assets-manifest",
			resolveId: {
				filter: { id: exactRegex("virtual:vite-rsc/assets-manifest") },
				handler(source) {
					if (source === "virtual:vite-rsc/assets-manifest") {
						if (this.environment.mode === "build") return {
							id: source,
							external: true
						};
						return `\0` + source;
					}
				}
			},
			load: {
				filter: { id: exactRegex("\0virtual:vite-rsc/assets-manifest") },
				handler(id) {
					if (id === "\0virtual:vite-rsc/assets-manifest") {
						assert(this.environment.name !== "client");
						assert(this.environment.mode === "dev");
						const manifest = {
							bootstrapScriptContent: `import(${serializeValueWithRuntime(assetsURL("@id/__x00__" + VIRTUAL_ENTRIES.browser, manager))})`,
							clientReferenceDeps: {},
							cssLinkPrecedence: rscPluginOptions.cssLinkPrecedence
						};
						return `export default ${JSON.stringify(manifest, null, 2)}`;
					}
				}
			},
			generateBundle(_options, bundle) {
				manager.bundles[this.environment.name] = bundle;
				if (this.environment.name === "client") {
					const filterAssets = rscPluginOptions.copyServerAssetsToClient ?? (() => true);
					const rscBuildOptions = manager.config.environments.rsc.build;
					const rscViteManifest = typeof rscBuildOptions.manifest === "string" ? rscBuildOptions.manifest : rscBuildOptions.manifest && ".vite/manifest.json";
					for (const asset of Object.values(manager.bundles["rsc"])) {
						if (asset.fileName === rscViteManifest) continue;
						if (asset.type === "asset" && filterAssets(asset.fileName)) this.emitFile({
							type: "asset",
							fileName: asset.fileName,
							source: asset.source
						});
					}
					const serverResources = {};
					const rscAssetDeps = collectAssetDeps(manager.bundles["rsc"]);
					for (const [id, meta] of Object.entries(manager.serverResourcesMetaMap)) serverResources[meta.key] = assetsURLOfDeps({
						js: [],
						css: rscAssetDeps[id]?.deps.css ?? []
					}, manager);
					const assetDeps = collectAssetDeps(bundle);
					let bootstrapScriptContent = "";
					const clientReferenceDeps = {};
					for (const meta of Object.values(manager.clientReferenceMetaMap)) {
						const deps = assetDeps[meta.groupChunkId]?.deps ?? {
							js: [],
							css: []
						};
						clientReferenceDeps[meta.referenceKey] = assetsURLOfDeps(deps, manager);
					}
					if (!rscPluginOptions.customClientEntry) {
						const entry = Object.values(assetDeps).find((v) => v.chunk.name === "index" && v.chunk.isEntry);
						if (!entry) throw new Error(`[vite-rsc] Client build must have an entry chunk named "index". Use 'customClientEntry' option to disable this requirement.`);
						const entryDeps = assetsURLOfDeps(entry.deps, manager);
						for (const [key, deps] of Object.entries(clientReferenceDeps)) clientReferenceDeps[key] = mergeAssetDeps(deps, entryDeps);
						const entryUrl = assetsURL(entry.chunk.fileName, manager);
						if (typeof entryUrl === "string") bootstrapScriptContent = `import(${JSON.stringify(entryUrl)})`;
						else bootstrapScriptContent = new RuntimeAsset(`"import(" + JSON.stringify(${entryUrl.runtime}) + ")"`);
					}
					manager.buildAssetsManifest = {
						bootstrapScriptContent,
						clientReferenceDeps,
						serverResources,
						cssLinkPrecedence: rscPluginOptions.cssLinkPrecedence
					};
				}
			},
			renderChunk(code, chunk) {
				if (code.includes("virtual:vite-rsc/assets-manifest")) {
					assert(this.environment.name !== "client");
					const replacement = normalizeRelativePath(path.relative(path.join(chunk.fileName, ".."), BUILD_ASSETS_MANIFEST_NAME));
					code = code.replaceAll("virtual:vite-rsc/assets-manifest", () => replacement);
					return { code };
				}
			}
		},
		createVirtualPlugin("vite-rsc/bootstrap-script-content", function() {
			assert(this.environment.name !== "client");
			return `\
import assetsManifest from "virtual:vite-rsc/assets-manifest";
export default assetsManifest.bootstrapScriptContent;
`;
		}),
		{
			name: "rsc:bootstrap-script-content",
			transform: {
				filter: { code: "loadBootstrapScriptContent" },
				async handler(code) {
					if (!code.includes("loadBootstrapScriptContent") || !/import\s*\.\s*meta\s*\.\s*viteRsc\s*\.\s*loadBootstrapScriptContent/.test(code)) return;
					assert(!rscPluginOptions.customClientEntry, `[vite-rsc] 'import.meta.viteRsc.loadBootstrapScriptContent' cannot be used with 'customClientEntry' option`);
					assert(this.environment.name !== "client");
					const output = new MagicString(code);
					for (const match of stripLiteral(code).matchAll(/import\s*\.\s*meta\s*\.\s*viteRsc\s*\.\s*loadBootstrapScriptContent\(([\s\S]*?)\)/dg)) {
						const [argStart, argEnd] = match.indices[1];
						const argCode = code.slice(argStart, argEnd).trim();
						assert(evalValue(argCode), `[vite-rsc] expected 'loadBootstrapScriptContent("index")' but got ${argCode}`);
						let replacement = `Promise.resolve(__vite_rsc_assets_manifest.bootstrapScriptContent)`;
						const [start, end] = match.indices[0];
						output.overwrite(start, end, replacement);
					}
					if (output.hasChanged()) {
						if (!code.includes("__vite_rsc_assets_manifest")) output.prepend(`import __vite_rsc_assets_manifest from "virtual:vite-rsc/assets-manifest";`);
						return {
							code: output.toString(),
							map: output.generateMap({ hires: "boundary" })
						};
					}
				}
			}
		},
		createVirtualPlugin(VIRTUAL_ENTRIES.browser.slice(8), async function() {
			assert(this.environment.mode === "dev");
			let code = "";
			if (await this.resolve("/@react-refresh")) code += `
import RefreshRuntime from "/@react-refresh";
RefreshRuntime.injectIntoGlobalHook(window);
window.$RefreshReg$ = () => {};
window.$RefreshSig$ = () => (type) => type;
window.__vite_plugin_react_preamble_installed__ = true;
`;
			const source = getEntrySource(this.environment.config, "index");
			const resolvedEntry = await this.resolve(source);
			assert(resolvedEntry, `[vite-rsc] failed to resolve entry '${source}'`);
			code += `await import(${JSON.stringify(resolvedEntry.id)});`;
			code += `
const ssrCss = document.querySelectorAll("link[rel='stylesheet']");
import.meta.hot.on("vite:beforeUpdate", () => {
  ssrCss.forEach(node => {
    if (node.dataset.precedence?.startsWith("vite-rsc/client-references")) {
      node.remove();
    }
  });
});
`;
			code += `
import.meta.hot.on("rsc:update", () => {
  document.querySelectorAll("vite-error-overlay").forEach((n) => n.close())
});
`;
			code += `import.meta.hot.on("rsc:prune", ${(e) => {
				document.querySelectorAll("link[rel='stylesheet']").forEach((node) => {
					if (e.paths.includes(node.dataset.rscCssHref)) node.remove();
				});
			}});`;
			return code;
		}),
		...vitePluginRscMinimal(rscPluginOptions, manager),
		...vitePluginImportEnvironment(manager),
		...vitePluginFindSourceMapURL(),
		...vitePluginRscCss(rscPluginOptions, manager),
		{
			...validateImportPlugin(),
			apply: () => rscPluginOptions.validateImports !== false
		},
		scanBuildStripPlugin({ manager }),
		...cjsModuleRunnerPlugin(),
		...globalAsyncLocalStoragePlugin()
	];
}
function globalAsyncLocalStoragePlugin() {
	return [{
		name: "rsc:inject-async-local-storage",
		transform: {
			filter: { code: "typeof AsyncLocalStorage" },
			handler(code) {
				if ((this.environment.name === "ssr" || this.environment.name === "rsc") && code.includes("typeof AsyncLocalStorage") && code.includes("new AsyncLocalStorage()") && !code.includes("__viteRscAsyncHooks")) return (this.environment.mode === "build" && !isRolldownVite ? `const __viteRscAsyncHooks = require("node:async_hooks");` : `import * as __viteRscAsyncHooks from "node:async_hooks";`) + `globalThis.AsyncLocalStorage = __viteRscAsyncHooks.AsyncLocalStorage;` + code;
			}
		}
	}];
}
function vitePluginUseClient(useClientPluginOptions, manager) {
	const packageSources = /* @__PURE__ */ new Map();
	const bareImportRE = /^(?![a-zA-Z]:)[\w@](?!.*:\/\/)/;
	const serverEnvironmentName = useClientPluginOptions.environment?.rsc ?? "rsc";
	const browserEnvironmentName = useClientPluginOptions.environment?.browser ?? "client";
	let optimizerMetadata;
	function warnInoncistentClientOptimization(ctx, id) {
		id = normalizePath(path.relative(process.cwd(), id));
		if (optimizerMetadata?.ids.includes(id)) ctx.warn("client component dependency is inconsistently optimized. It's recommended to add the dependency to 'optimizeDeps.exclude'.");
	}
	const debug = createDebug("vite-rsc:use-client");
	return [
		{
			name: "rsc:use-client",
			transform: { async handler(code, id) {
				if (this.environment.name !== serverEnvironmentName) return;
				if (!code.includes("use client")) {
					delete manager.clientReferenceMetaMap[id];
					return;
				}
				const ast = await parseAstAsync(code);
				if (!hasDirective(ast.body, "use client")) {
					delete manager.clientReferenceMetaMap[id];
					return;
				}
				if (code.includes("use server")) {
					const directives = findDirectives(ast, "use server");
					if (directives.length > 0) this.error(`'use server' directive is not allowed inside 'use client'`, directives[0]?.start);
				}
				let importId;
				let referenceKey;
				const packageSource = packageSources.get(id);
				if (!packageSource && this.environment.mode === "dev" && id.includes("/node_modules/")) {
					debug(`internal client reference created through a package imported in '${this.environment.name}' environment: ${id}`);
					id = cleanUrl(id);
					warnInoncistentClientOptimization(this, id);
					importId = `/@id/__x00__virtual:vite-rsc/client-in-server-package-proxy/${encodeURIComponent(id)}`;
					referenceKey = importId;
				} else if (packageSource) if (this.environment.mode === "dev") {
					importId = `/@id/__x00__virtual:vite-rsc/client-package-proxy/${packageSource}`;
					referenceKey = importId;
				} else {
					importId = packageSource;
					referenceKey = hashString(packageSource);
				}
				else if (this.environment.mode === "dev") {
					importId = normalizeViteImportAnalysisUrl(manager.server.environments[browserEnvironmentName], id);
					referenceKey = importId;
				} else {
					importId = id;
					referenceKey = hashString(manager.toRelativeId(id));
				}
				const result = withRollupError(this, transformDirectiveProxyExport)(ast, {
					directive: "use client",
					code,
					keep: !!useClientPluginOptions.keepUseCientProxy,
					runtime: (name, meta) => {
						let proxyValue = `() => { throw new Error("Unexpectedly client reference export '" + ` + JSON.stringify(name) + ` + "' is called on server") }`;
						if (meta?.value) proxyValue = `(${meta.value})`;
						return `$$ReactServer.registerClientReference(  ${proxyValue},  ${JSON.stringify(referenceKey)},  ${JSON.stringify(name)})`;
					}
				});
				if (!result) return;
				const { output, exportNames } = result;
				manager.clientReferenceMetaMap[id] = {
					importId,
					referenceKey,
					packageSource,
					exportNames,
					renderedExports: []
				};
				const importSource = resolvePackage(`${PKG_NAME}/react/rsc`);
				output.prepend(`import * as $$ReactServer from "${importSource}";\n`);
				return {
					code: output.toString(),
					map: { mappings: "" }
				};
			} }
		},
		{
			name: "rsc:use-client/build-references",
			resolveId: {
				filter: { id: prefixRegex("virtual:vite-rsc/client-references") },
				handler(source) {
					if (source.startsWith("virtual:vite-rsc/client-references")) return "\0" + source;
				}
			},
			load: {
				filter: { id: prefixRegex("\0virtual:vite-rsc/client-references") },
				handler(id) {
					if (id === "\0virtual:vite-rsc/client-references") {
						if (this.environment.mode === "dev") return {
							code: `export default {}`,
							map: null
						};
						if (manager.isScanBuild) {
							let code = ``;
							for (const meta of Object.values(manager.clientReferenceMetaMap)) code += `import ${JSON.stringify(withResolvedIdProxy(meta.importId))};\n`;
							return {
								code,
								map: null
							};
						}
						let code = "";
						manager.clientReferenceGroups = {};
						for (const meta of Object.values(manager.clientReferenceMetaMap)) {
							if (!meta.serverChunk) continue;
							let name = useClientPluginOptions.clientChunks?.({
								id: meta.importId,
								normalizedId: manager.toRelativeId(meta.importId),
								serverChunk: meta.serverChunk
							}) ?? meta.serverChunk;
							name = cleanUrl(name.replaceAll("..", "__"));
							(manager.clientReferenceGroups[name] ??= []).push(meta);
							meta.groupChunkId = `\0virtual:vite-rsc/client-references/group/${name}`;
						}
						debug("client-reference-groups", manager.clientReferenceGroups);
						for (const [name, metas] of Object.entries(manager.clientReferenceGroups)) {
							const groupVirtual = `virtual:vite-rsc/client-references/group/${name}`;
							for (const meta of metas) code += `\
                ${JSON.stringify(meta.referenceKey)}: async () => {
                  const m = await import(${JSON.stringify(groupVirtual)});
                  return m.export_${meta.referenceKey};
                },
              `;
						}
						code = `export default {${code}};\n`;
						return {
							code,
							map: null
						};
					}
					if (id.startsWith("\0virtual:vite-rsc/client-references/group/")) {
						const name = id.slice(42);
						const metas = manager.clientReferenceGroups[name];
						assert(metas, `unknown client reference group: ${name}`);
						let code = ``;
						for (const meta of metas) {
							const exports = meta.renderedExports.map((name) => `${name}: import_${meta.referenceKey}.${name},\n`).sort().join("");
							code += `
              import * as import_${meta.referenceKey} from ${JSON.stringify(withResolvedIdProxy(meta.importId))};
              export const export_${meta.referenceKey} = {${exports}};
            `;
						}
						return {
							code,
							map: null
						};
					}
				}
			}
		},
		{
			name: "rsc:virtual-client-in-server-package",
			load: {
				filter: { id: prefixRegex("\0virtual:vite-rsc/client-in-server-package-proxy/") },
				async handler(id) {
					if (id.startsWith("\0virtual:vite-rsc/client-in-server-package-proxy/")) {
						assert.equal(this.environment.mode, "dev");
						assert(this.environment.name !== serverEnvironmentName);
						id = decodeURIComponent(id.slice(49));
						return `
            export * from ${JSON.stringify(id)};
            import * as __all__ from ${JSON.stringify(id)};
            export default __all__.default;
          `;
					}
				}
			}
		},
		{
			name: "rsc:virtual-client-package",
			resolveId: {
				order: "pre",
				async handler(source, importer, options) {
					if (this.environment.name === serverEnvironmentName && bareImportRE.test(source) && !(source === "client-only" || source === "server-only")) {
						const resolved = await this.resolve(source, importer, options);
						if (resolved && resolved.id.includes("/node_modules/")) {
							packageSources.set(resolved.id, source);
							return resolved;
						}
					}
				}
			},
			load: {
				filter: { id: prefixRegex("\0virtual:vite-rsc/client-package-proxy/") },
				async handler(id) {
					if (id.startsWith("\0virtual:vite-rsc/client-package-proxy/")) {
						assert(this.environment.mode === "dev");
						const source = id.slice(39);
						return `export {${Object.values(manager.clientReferenceMetaMap).find((v) => v.packageSource === source).exportNames.join(",")}} from ${JSON.stringify(source)};\n`;
					}
				}
			},
			generateBundle(_options, bundle) {
				if (manager.isScanBuild) return;
				if (this.environment.name !== serverEnvironmentName) return;
				for (const chunk of Object.values(bundle)) if (chunk.type === "chunk") {
					const metas = [];
					for (const id of chunk.moduleIds) {
						const meta = manager.clientReferenceMetaMap[id];
						if (meta) metas.push([id, meta]);
					}
					if (metas.length > 0) {
						let serverChunk;
						if (chunk.facadeModuleId) serverChunk = "facade:" + manager.toRelativeId(chunk.facadeModuleId);
						else serverChunk = "shared:" + manager.toRelativeId(metas.map(([id]) => id).sort()[0]);
						for (const [id, meta] of metas) {
							const mod = chunk.modules[id];
							assert(mod);
							meta.renderedExports = mod.renderedExports;
							meta.serverChunk = serverChunk;
						}
					}
				}
			}
		},
		...customOptimizerMetadataPlugin({ setMetadata: (metadata) => {
			optimizerMetadata = metadata;
		} })
	];
}
function customOptimizerMetadataPlugin({ setMetadata }) {
	const MEATADATA_FILE = "_metadata-rsc.json";
	function optimizerPluginEsbuild() {
		return {
			name: "vite-rsc-metafile",
			setup(build) {
				build.onEnd((result) => {
					if (!result.metafile?.inputs || !build.initialOptions.outdir) return;
					const metadata = { ids: Object.keys(result.metafile.inputs) };
					setMetadata(metadata);
					fs.writeFileSync(path.join(build.initialOptions.outdir, MEATADATA_FILE), JSON.stringify(metadata, null, 2));
				});
			}
		};
	}
	function optimizerPluginRolldown() {
		return {
			name: "vite-rsc-metafile",
			writeBundle(options) {
				assert(options.dir);
				const metadata = { ids: [...this.getModuleIds()].map((id) => path.relative(process.cwd(), id)) };
				setMetadata(metadata);
				fs.writeFileSync(path.join(options.dir, MEATADATA_FILE), JSON.stringify(metadata, null, 2));
			}
		};
	}
	return [{
		name: "rsc:use-client:optimizer-metadata",
		apply: "serve",
		config() {
			return { environments: { client: { optimizeDeps: "rolldownVersion" in vite ? { rolldownOptions: { plugins: [optimizerPluginRolldown()] } } : { esbuildOptions: { plugins: [optimizerPluginEsbuild()] } } } } };
		},
		configResolved(config) {
			const file = path.join(config.cacheDir, "deps", MEATADATA_FILE);
			if (fs.existsSync(file)) try {
				setMetadata(JSON.parse(fs.readFileSync(file, "utf-8")));
			} catch (e) {
				this.warn(`failed to load '${file}'`);
			}
		}
	}];
}
function vitePluginDefineEncryptionKey(useServerPluginOptions) {
	let defineEncryptionKey;
	let emitEncryptionKey = false;
	const KEY_PLACEHOLDER = "__vite_rsc_define_encryption_key";
	const KEY_FILE = "__vite_rsc_encryption_key.js";
	const serverEnvironmentName = useServerPluginOptions.environment?.rsc ?? "rsc";
	return [{
		name: "rsc:encryption-key",
		async configEnvironment(name, _config, env) {
			if (name === serverEnvironmentName && !env.isPreview) defineEncryptionKey = useServerPluginOptions.defineEncryptionKey ?? JSON.stringify(toBase64(await generateEncryptionKey()));
		},
		resolveId: {
			filter: { id: exactRegex("virtual:vite-rsc/encryption-key") },
			handler(source) {
				if (source === "virtual:vite-rsc/encryption-key") return {
					id: "\0" + source,
					moduleSideEffects: false
				};
			}
		},
		load: {
			filter: { id: exactRegex("\0virtual:vite-rsc/encryption-key") },
			handler(id) {
				if (id === "\0virtual:vite-rsc/encryption-key") {
					if (this.environment.mode === "build") return `export default () => ${KEY_PLACEHOLDER}`;
					return `export default () => (${defineEncryptionKey})`;
				}
			}
		},
		renderChunk(code, chunk) {
			if (code.includes(KEY_PLACEHOLDER)) {
				assert.equal(this.environment.name, serverEnvironmentName);
				emitEncryptionKey = true;
				const normalizedPath = normalizeRelativePath(path.relative(path.join(chunk.fileName, ".."), KEY_FILE));
				const replacement = `import(${JSON.stringify(normalizedPath)}).then(__m => __m.default)`;
				code = code.replaceAll(KEY_PLACEHOLDER, () => replacement);
				return { code };
			}
		},
		writeBundle() {
			if (this.environment.name === serverEnvironmentName && emitEncryptionKey) fs.writeFileSync(path.join(this.environment.config.build.outDir, KEY_FILE), `export default ${defineEncryptionKey};\n`);
		}
	}];
}
function vitePluginUseServer(useServerPluginOptions, manager) {
	const serverEnvironmentName = useServerPluginOptions.environment?.rsc ?? "rsc";
	const browserEnvironmentName = useServerPluginOptions.environment?.browser ?? "client";
	const debug = createDebug("vite-rsc:use-server");
	return [{
		name: "rsc:use-server",
		transform: { async handler(code, id) {
			if (!code.includes("use server")) {
				delete manager.serverReferenceMetaMap[id];
				return;
			}
			const ast = await parseAstAsync(code);
			let normalizedId_;
			const getNormalizedId = () => {
				if (!normalizedId_) {
					if (this.environment.mode === "dev" && id.includes("/node_modules/")) {
						debug(`internal server reference created through a package imported in ${this.environment.name} environment: ${id}`);
						id = cleanUrl(id);
					}
					if (manager.config.command === "build") normalizedId_ = hashString(manager.toRelativeId(id));
					else normalizedId_ = normalizeViteImportAnalysisUrl(manager.server.environments[serverEnvironmentName], id);
				}
				return normalizedId_;
			};
			if (this.environment.name === serverEnvironmentName) {
				const transformServerActionServer_ = withRollupError(this, transformServerActionServer);
				const enableEncryption = useServerPluginOptions.enableActionEncryption ?? true;
				const result = transformServerActionServer_(code, ast, {
					runtime: (value, name) => `$$ReactServer.registerServerReference(${value}, ${JSON.stringify(getNormalizedId())}, ${JSON.stringify(name)})`,
					rejectNonAsyncFunction: true,
					encode: enableEncryption ? (value) => `__vite_rsc_encryption_runtime.encryptActionBoundArgs(${value})` : void 0,
					decode: enableEncryption ? (value) => `await __vite_rsc_encryption_runtime.decryptActionBoundArgs(${value})` : void 0
				});
				const output = result.output;
				if (!result || !output.hasChanged()) {
					delete manager.serverReferenceMetaMap[id];
					return;
				}
				manager.serverReferenceMetaMap[id] = {
					importId: id,
					referenceKey: getNormalizedId(),
					exportNames: "names" in result ? result.names : result.exportNames
				};
				const importSource = resolvePackage(`${PKG_NAME}/react/rsc`);
				output.prepend(`import * as $$ReactServer from "${importSource}";\n`);
				if (enableEncryption) {
					const importSource = resolvePackage(`${PKG_NAME}/utils/encryption-runtime`);
					output.prepend(`import * as __vite_rsc_encryption_runtime from ${JSON.stringify(importSource)};\n`);
				}
				return {
					code: output.toString(),
					map: output.generateMap({ hires: "boundary" })
				};
			} else {
				if (!hasDirective(ast.body, "use server")) {
					delete manager.serverReferenceMetaMap[id];
					return;
				}
				const result = withRollupError(this, transformDirectiveProxyExport)(ast, {
					code,
					runtime: (name) => `$$ReactClient.createServerReference(${JSON.stringify(getNormalizedId() + "#" + name)},$$ReactClient.callServer, undefined, ` + (this.environment.mode === "dev" ? `$$ReactClient.findSourceMapURL,` : "undefined,") + `${JSON.stringify(name)})`,
					directive: "use server",
					rejectNonAsyncFunction: true
				});
				if (!result) return;
				const output = result?.output;
				if (!output?.hasChanged()) return;
				manager.serverReferenceMetaMap[id] = {
					importId: id,
					referenceKey: getNormalizedId(),
					exportNames: result.exportNames
				};
				const importSource = resolvePackage(`${PKG_NAME}/react/${this.environment.name === browserEnvironmentName ? "browser" : "ssr"}`);
				output.prepend(`import * as $$ReactClient from "${importSource}";\n`);
				return {
					code: output.toString(),
					map: output.generateMap({ hires: "boundary" })
				};
			}
		} }
	}, createVirtualPlugin("vite-rsc/server-references", function() {
		if (this.environment.mode === "dev") return {
			code: `export {}`,
			map: null
		};
		let code = "";
		for (const meta of Object.values(manager.serverReferenceMetaMap)) {
			const key = JSON.stringify(meta.referenceKey);
			const id = JSON.stringify(meta.importId);
			const exports = meta.exportNames.map((name) => name === "default" ? "default: _default" : name).sort();
			code += `
  ${key}: async () => {
    const {${exports}} = await import(${id});
    return {${exports}};
  },
`;
		}
		code = `export default {${code}};\n`;
		return {
			code,
			map: null
		};
	})];
}
var RuntimeAsset = class {
	runtime;
	constructor(value) {
		this.runtime = value;
	}
};
function serializeValueWithRuntime(value) {
	const replacements = [];
	let result = JSON.stringify(value, (_key, value) => {
		if (value instanceof RuntimeAsset) {
			const placeholder = `__runtime_placeholder_${replacements.length}__`;
			replacements.push([placeholder, value.runtime]);
			return placeholder;
		}
		return value;
	}, 2);
	for (const [placeholder, runtime] of replacements) result = result.replace(`"${placeholder}"`, runtime);
	return result;
}
function assetsURL(url, manager) {
	const { config } = manager;
	if (config.command === "build" && typeof config.experimental?.renderBuiltUrl === "function") {
		const result = config.experimental.renderBuiltUrl(url, {
			type: "asset",
			hostType: "js",
			ssr: true,
			hostId: ""
		});
		if (typeof result === "object") {
			if (result.runtime) return new RuntimeAsset(result.runtime);
			assert(!result.relative, "\"result.relative\" not supported on renderBuiltUrl() for RSC");
		} else if (result) return result;
	}
	return config.base + url;
}
function assetsURLOfDeps(deps, manager) {
	return {
		js: deps.js.map((href) => {
			assert(typeof href === "string");
			return assetsURL(href, manager);
		}),
		css: deps.css.map((href) => {
			assert(typeof href === "string");
			return assetsURL(href, manager);
		})
	};
}
function mergeAssetDeps(a, b) {
	return {
		js: [...new Set([...a.js, ...b.js])],
		css: [...new Set([...a.css, ...b.css])]
	};
}
function collectAssetDeps(bundle) {
	const chunkToDeps = /* @__PURE__ */ new Map();
	for (const chunk of Object.values(bundle)) if (chunk.type === "chunk") chunkToDeps.set(chunk, collectAssetDepsInner(chunk.fileName, bundle));
	const idToDeps = {};
	for (const [chunk, deps] of chunkToDeps.entries()) for (const id of chunk.moduleIds) idToDeps[id] = {
		chunk,
		deps
	};
	return idToDeps;
}
function collectAssetDepsInner(fileName, bundle) {
	const visited = /* @__PURE__ */ new Set();
	const css = [];
	function recurse(k) {
		if (visited.has(k)) return;
		visited.add(k);
		const v = bundle[k];
		assert(v, `Not found '${k}' in the bundle`);
		if (v.type === "chunk") {
			css.push(...v.viteMetadata?.importedCss ?? []);
			for (const k2 of v.imports) if (k2 in bundle) recurse(k2);
		}
	}
	recurse(fileName);
	return {
		js: [...visited],
		css: [...new Set(css)]
	};
}
function vitePluginRscCss(rscCssOptions = {}, manager) {
	function hasSpecialCssQuery(id) {
		return /[?&](url|inline|raw)(\b|=|&|$)/.test(id);
	}
	function collectCss(environment, entryId) {
		const visited = /* @__PURE__ */ new Set();
		const cssIds = /* @__PURE__ */ new Set();
		const visitedFiles = /* @__PURE__ */ new Set();
		function recurse(id) {
			if (visited.has(id)) return;
			visited.add(id);
			const mod = environment.moduleGraph.getModuleById(id);
			if (mod?.file) visitedFiles.add(mod.file);
			for (const next of mod?.importedModules ?? []) if (next.id) if (isCSSRequest(next.id)) {
				if (hasSpecialCssQuery(next.id)) continue;
				cssIds.add(next.id);
			} else recurse(next.id);
		}
		recurse(entryId);
		const hrefs = [...cssIds].map((id) => normalizeViteImportAnalysisUrl(environment, id));
		return {
			ids: [...cssIds],
			hrefs,
			visitedFiles: [...visitedFiles]
		};
	}
	function getRscCssTransformFilter({ id, code }) {
		const { filename, query } = parseIdQuery(id);
		if ("vite-rsc-css-export" in query) {
			const value = query["vite-rsc-css-export"];
			if (value) {
				const names = value.split(",");
				return (name) => names.includes(name);
			}
			return (name) => /^[A-Z]/.test(name);
		}
		const options = rscCssOptions?.rscCssTransform;
		if (options === false) return false;
		if (options?.filter && !options.filter(filename)) return false;
		if (!/\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)\b/.test(code) || !/\.[tj]sx?$/.test(filename)) return false;
		if (!esModuleLexer.parse(code)[0].some((i) => i.t === 1 && i.n && isCSSRequest(i.n))) return false;
		return (_name, meta) => !!(meta.isFunction && meta.declName && /^[A-Z]/.test(meta.declName) || meta.defaultExportIdentifierName && /^[A-Z]/.test(meta.defaultExportIdentifierName));
	}
	return [
		{
			name: "rsc:rsc-css-export-transform",
			transform: { async handler(code, id) {
				if (this.environment.name !== "rsc") return;
				const filter = getRscCssTransformFilter({
					id,
					code
				});
				if (!filter) return;
				const result = await transformRscCssExport({
					ast: await parseAstAsync(code),
					code,
					filter
				});
				if (result) return {
					code: result.output.toString(),
					map: result.output.generateMap({ hires: "boundary" })
				};
			} }
		},
		{
			name: "rsc:rsc-css-self-accept",
			apply: "serve",
			transform: {
				order: "post",
				filter: { id: /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(\?|$)/ },
				handler(_code, id, _options) {
					if (this.environment.name === "client" && this.environment.mode === "dev" && isCSSRequest(id) && directRequestRE.test(id)) {
						const mod = this.environment.moduleGraph.getModuleById(id);
						if (mod && !mod.isSelfAccepting) mod.isSelfAccepting = true;
					}
				}
			}
		},
		{
			name: "rsc:css-virtual",
			resolveId: {
				filter: { id: prefixRegex("virtual:vite-rsc/css?") },
				handler(source) {
					if (source.startsWith("virtual:vite-rsc/css?")) return "\0" + source;
				}
			},
			load: {
				filter: { id: prefixRegex("\0virtual:vite-rsc/css?") },
				async handler(id) {
					const parsed = parseCssVirtual(id);
					if (parsed?.type === "ssr") {
						id = parsed.id;
						const { server } = manager;
						const mod = await server.environments.ssr.moduleGraph.getModuleByUrl(id);
						if (!mod?.id || !mod?.file) return `export default []`;
						const result = collectCss(server.environments.ssr, mod.id);
						for (const file of [mod.file, ...result.visitedFiles]) this.addWatchFile(file);
						return `export default ${serializeValueWithRuntime(result.hrefs.map((href) => assetsURL(href.slice(1), manager)))}`;
					}
				}
			}
		},
		{
			name: "rsc:importer-resources",
			configureServer(server) {
				const hot = server.environments.rsc.hot;
				const original = hot.send;
				hot.send = function(...args) {
					const e = args[0];
					if (e && typeof e === "object" && e.type === "prune") server.environments.client.hot.send({
						type: "custom",
						event: "rsc:prune",
						data: e
					});
					return original.apply(this, args);
				};
			},
			transform: {
				filter: { code: "import.meta.viteRsc.loadCss" },
				async handler(code, id) {
					if (!code.includes("import.meta.viteRsc.loadCss")) return;
					assert(this.environment.name === "rsc");
					const output = new MagicString(code);
					let importAdded = false;
					for (const match of stripLiteral(code).matchAll(/import\.meta\.viteRsc\.loadCss\(([\s\S]*?)\)/dg)) {
						const [start, end] = match.indices[0];
						const [argStart, argEnd] = match.indices[1];
						const argCode = code.slice(argStart, argEnd).trim();
						let importer = id;
						if (argCode) {
							const argValue = evalValue(argCode);
							const resolved = await this.resolve(argValue, id);
							if (resolved) importer = resolved.id;
							else {
								this.warn(`[vite-rsc] failed to transform 'import.meta.viteRsc.loadCss(${argCode})'`);
								output.update(start, end, `null`);
								continue;
							}
						}
						const importId = toCssVirtual({
							id: importer,
							type: "rsc"
						});
						let replacement;
						if (this.environment.mode === "dev") replacement = `__vite_rsc_react__.createElement(async () => {
              const __m = await import(${JSON.stringify(importId)});
              return __vite_rsc_react__.createElement(__m.Resources);
            })`;
						else {
							const hash = hashString(importId);
							if (!importAdded && !code.includes(`__vite_rsc_importer_resources_${hash}`)) {
								importAdded = true;
								output.prepend(`import * as __vite_rsc_importer_resources_${hash} from ${JSON.stringify(importId)};`);
							}
							replacement = `__vite_rsc_react__.createElement(__vite_rsc_importer_resources_${hash}.Resources)`;
						}
						output.update(start, end, replacement);
					}
					if (output.hasChanged()) {
						if (!code.includes("__vite_rsc_react__")) output.prepend(`import __vite_rsc_react__ from "react";`);
						return {
							code: output.toString(),
							map: output.generateMap({ hires: "boundary" })
						};
					}
				}
			},
			load: {
				filter: { id: prefixRegex("\0virtual:vite-rsc/css?") },
				handler(id) {
					const { server } = manager;
					const parsed = parseCssVirtual(id);
					if (parsed?.type === "rsc") {
						assert(this.environment.name === "rsc");
						const importer = parsed.id;
						if (this.environment.mode === "dev") {
							const result = collectCss(server.environments.rsc, importer);
							for (const file of [importer, ...result.visitedFiles]) this.addWatchFile(file);
							return generateResourcesCode(serializeValueWithRuntime(assetsURLOfDeps({
								css: result.hrefs.map((href) => href.slice(1)),
								js: []
							}, manager)), manager, { cssLinkPrecedence: rscCssOptions.cssLinkPrecedence });
						} else {
							const key = manager.toRelativeId(importer);
							manager.serverResourcesMetaMap[importer] = { key };
							return `
              import __vite_rsc_assets_manifest__ from "virtual:vite-rsc/assets-manifest";
              ${generateResourcesCode(`__vite_rsc_assets_manifest__.serverResources[${JSON.stringify(key)}]`, manager, { cssLinkPrecedence: rscCssOptions.cssLinkPrecedence })}
            `;
						}
					}
				}
			}
		},
		createVirtualPlugin("vite-rsc/remove-duplicate-server-css", async function() {
			assert.equal(this.environment.mode, "dev");
			function removeFn() {
				document.querySelectorAll("link[rel='stylesheet']").forEach((node) => {
					if (node instanceof HTMLElement && node.dataset.precedence?.startsWith("vite-rsc/client-reference")) node.remove();
				});
			}
			return `\
"use client"
import React from "react";
export default function RemoveDuplicateServerCss() {
  React.useEffect(() => {
    (${removeFn.toString()})();
  }, []);
  return null;
}
`;
		})
	];
}
function generateResourcesCode(depsCode, manager, options = {}) {
	const usePrecedence = options.cssLinkPrecedence !== false;
	const ResourcesFn = (React, deps, RemoveDuplicateServerCss, precedence) => {
		return function Resources() {
			return React.createElement(React.Fragment, null, [...deps.css.map((href) => React.createElement("link", {
				key: "css:" + href,
				rel: "stylesheet",
				...precedence ? { precedence } : {},
				href,
				"data-rsc-css-href": href
			})), RemoveDuplicateServerCss && React.createElement(RemoveDuplicateServerCss, { key: "remove-duplicate-css" })]);
		};
	};
	return `
import __vite_rsc_react__ from "react";

${manager.config.command === "serve" ? `import RemoveDuplicateServerCss from "virtual:vite-rsc/remove-duplicate-server-css";` : `const RemoveDuplicateServerCss = undefined;`}

export const Resources = (${ResourcesFn.toString()})(
  __vite_rsc_react__,
  ${depsCode},
  RemoveDuplicateServerCss,
  ${usePrecedence ? `"vite-rsc/importer-resources"` : `undefined`},
);
`;
}
async function transformRscCssExport(options) {
	if (hasDirective(options.ast.body, "use client")) return;
	const result = transformWrapExport(options.code, options.ast, {
		runtime: (value, name, meta) => `__vite_rsc_wrap_css__(${value}, ${JSON.stringify(meta.defaultExportIdentifierName ?? name)})`,
		filter: options.filter,
		ignoreExportAllDeclaration: true
	});
	if (result.output.hasChanged()) {
		if (!options.code.includes("__vite_rsc_react__")) result.output.prepend(`import __vite_rsc_react__ from "react";`);
		result.output.append(`
function __vite_rsc_wrap_css__(value, name) {
  if (typeof value !== 'function') return value;

  function __wrapper(props) {
    return __vite_rsc_react__.createElement(
      __vite_rsc_react__.Fragment,
      null,
      import.meta.viteRsc.loadCss(${options.id ? JSON.stringify(options.id) : ""}),
      __vite_rsc_react__.createElement(value, props),
    );
  }
  Object.defineProperty(__wrapper, "name", { value: name });
  return __wrapper;
}
`);
		return { output: result.output };
	}
}

//#endregion
export { vitePluginRscMinimal as i, transformRscCssExport as n, vitePluginRsc as r, getPluginApi as t };